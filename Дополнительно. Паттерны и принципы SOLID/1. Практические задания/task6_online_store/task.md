 Задача: 
 Разработать систему для управления товарами и заказами в интернет-магазине.
 
* **Принцип единой ответственности**: 
Создайте отдельные классы для управления продуктами и заказами, каждый с определенными обязанностями.

* **Принцип открытости/закрытости**: 
Сделайте классы управления продуктами и заказами открытыми для расширения, но закрытыми для модификации. Этого можно достичь, используя наследование и полиморфизм.

* **Принцип замены Лискова**: 
Используйте наследование и полиморфизм, чтобы гарантировать, что любой производный класс может быть использован вместо своего базового класса, не влияя на поведение системы.

* **Принцип разделения интерфейсов**: 
Определите отдельные интерфейсы для управления продуктами и заказами, чтобы избежать принуждения классов к реализации методов, которые им не нужны.

* **Принцип инверсии зависимостей**: 
Используйте внедрение зависимостей, чтобы отделить классы и сделать их зависимыми от абстракций, а не от конкретных реализаций.

В этом примере класс `OnlineStore` реализует бизнес-логику для управления продуктами и заказами, 
а классы `ProductRepository` и `OrderRepository` обрабатывают хранилище данных. 

Внедряя репозитории в качестве зависимостей, система становится более гибкой и ремонтопригодной.

Класс `OnlineStore` может быть расширен несколькими способами для добавления новых функциональных возможностей: 

* Путем добавления новых методов к классам ProductRepository и OrderRepository, например, для обработки категорий товаров, скидок или вариантов доставки.

* Путем создания новых репозиториев для различных типов данных, таких как информация о клиенте или платежные реквизиты, и внедрения их в качестве зависимостей в класс `OnlineStore`.

* Путем создания новых классов, наследуемых от класса `OnlineStore`, и добавления новых методов или переопределения существующих для обеспечения дополнительной функциональности. Например, можно создать новый класс для обработки продаж и рекламных акций или для создания отчетов.

Главное - следовать принципам SOLID, особенно принципу Open/Closed, делая систему открытой для расширения, но закрытой для модификации. 
Таким образом, новая функциональность может быть добавлена без изменения существующего кода, что делает систему более гибкой и ремонтопригодной.