# Теоретическое задание (прочитать, запустить, ознакомиться с кодом)

## А как вообще можно создать атрибуты и как ими управлять?

Мы знаем, что можно просто добавить атрибут непосредственно через экземпляр, в качестве примере возьмем класс `Point2D` из 
рассматриваемого файла. Помним, что изменение и добавление атрибута аналогичны по синтаксису.

```python
point = Point2D(1, 1)
print(point.x, point.y)  # 1 1
point.z = 20
print(point.x, point.y, point.z)  # 1 1 20
```

Существует и другой способ, это использование функции `setattr`, она на вход принимает 3 аргумента:
* Экземпляр класса, где нужно обновить значение атрибута и создать атрибут
* Название атрибута
* Значение атрибута

Так модифицируется прошлый код с использованием `setattr`

```python
point = Point2D(1, 1)
print(point.x, point.y)  # 1 1
setattr(point, 'z', 20)
print(point.x, point.y, point.z)  # 1 1 20
```

Функция `setattr` полезна в случаях, когда нужно динамически управлять атрибутами объектов, особенно в условиях неопределенности структуры данных, для создания гибких и динамических программ.

И наконец мы можем создать метод в классе `Point2D` с использованием словаря `__dict__`

Для примера:

```python
class Point2D:
    def __init__(self, x: (int, float) = 0, y: (int, float) = 0):
        self.x = x
        self.y = y

    def add_new_attr(self, attr: str, value: (int, float)):
        self.__dict__[attr] = value

point = Point2D(1, 1)
print(point.x, point.y)  # 1 1
point.add_new_attr('z', 20)
print(point.x, point.y, point.z)  # 1 1 20
```

# Однако! Хотя добавление атрибутов через `self.__dict__` возможно, но в большинстве случаев это не является хорошей практикой . 

Вот ключевые моменты, которые следует учитывать:

1. Прямой доступ к `__dict__` и его риски:

> `__dict__` — это словарь, который содержит все атрибуты экземпляра класса (если они хранятся в стандартной форме). Прямое изменение `__dict__` позволяет динамически добавлять, изменять или удалять атрибуты объекта.

> Однако такой подход нарушает инкапсуляцию и абстракцию, поскольку вы работаете напрямую с внутренней структурой объекта. Это может привести к ошибкам, трудным для отладки, особенно если имя атрибута совпадает с системными атрибутами или если объект использует другие механизмы хранения атрибутов, такие как `__slots__`.

2. Ограничения и проблемы:

> `Обход механизмов установки атрибутов`: Добавление атрибута через `self.__dict__` обходит методы `__setattr__` и другие связанные методы, которые могли бы контролировать процесс установки атрибутов. Это может привести к некорректному состоянию объекта, если эти методы используются для валидации или выполнения других задач.

> `Совместимость с __slots__`: Если класс использует `__slots__`, у объекта может отсутствовать атрибут `__dict__`. В таком случае попытка напрямую изменить `__dict__` приведёт к ошибке.

> `Потенциальные конфликты`: Прямое добавление атрибутов через `__dict__` может привести к случайному переопределению существующих атрибутов, что также увеличивает риск ошибок.

## Так что же такое `__slots__`?

`__slots__` — это механизм, который позволяет ограничить набор атрибутов экземпляра класса, тем самым снижая объем памяти, 
используемой объектами, и улучшая производительность. Когда класс использует `__slots__`, он ограничивает атрибуты 
экземпляра только теми, которые явно указаны в этом атрибуте, и предотвращает создание `__dict__` для объекта.

Другими словами, если хотите запретить создание новых атрибутов кроме тех, которые вы сами прописали, то просто укажите это в атрибуте `__slots__`, так вы
защитите свой экземпляр класса от несанкционированного добавления атрибутов.

## Заключение

В большинстве случаев использование `self.__dict__` для добавления атрибутов не рекомендуется, так как это снижает читаемость кода и увеличивает риск ошибок. 
Безопаснее и правильнее использовать такие механизмы, как `setattr` или обычное присваивание атрибутов через `self.attr = value`, 
что сохраняет инкапсуляцию и делает код более понятным и устойчивым к ошибкам.

