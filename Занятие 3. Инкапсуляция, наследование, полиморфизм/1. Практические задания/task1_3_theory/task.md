# Теоретическое задание (прочитать, запустить, ознакомиться с кодом)

Ранее было рассказано по защищенности атрибутов (в литературе их ещё называют `модификаторы доступа`)

Чаще всего их используют для того, чтобы скрыть внутренние проверки валидации. Возьмем для примера класс прямоугольник,
в котором можно задать ширину и высоту, получить эти значения при помощи соответствующих методов гетеров (get), а также
установить значения при помощи соответствующих методов сеттеров (set).

Атрибуты защищенные, чтобы исключить возможность изменять их извне.  

```python
class Rectangle:
    def __init__(self, width: float, height: float):
        self._width = width
        self._height = height

    def get_width(self) -> float:
        """Метод для получения ширины"""
        return self._width

    def set_width(self, value: float):
        """Метод для установки ширины с проверкой"""
        if value <= 0:
            raise ValueError("Ширина должна быть положительным числом")
        self._width = value

    def get_height(self) -> float:
        """Метод для получения высоты"""
        return self._height

    def set_height(self, value: float):
        """Метод для установки высоты с проверкой"""
        if value <= 0:
            raise ValueError("Высота должна быть положительным числом")
        self._height = value

    def area(self) -> float:
        """Вычисляемый метод для площади прямоугольника"""
        return self._width * self._height

if __name__ == "__main__":
    
    # Пример использования
    rect = Rectangle(5, 10)
    
    print(rect.get_width())  # 5
    rect.set_width(7)
    print(rect.area())  # 70
    
    try:
        rect.set_width(-3)  # Ошибка: ValueError: Ширина должна быть положительным числом
    except ValueError as err:
        print(repr(err))
```

Для визуального упрощения работы с концепцией setter и getter в Python есть концепция под названием свойства. Свойства также
бывают setter и getter.

Свойства (`properties`) в Python представляют собой механизм, который позволяет управлять доступом к атрибутам класса, предлагая интерфейс, 
похожий на доступ к обычным атрибутам, но с возможностью добавить логику при чтении, записи и удалении значений. 
Свойства позволяют реализовать инкапсуляцию, обеспечивая контроль над тем, как к атрибутам получают доступ и как их изменяют.

Свойства работают через декоратор `@property`. Чтобы создать свойство, необходимо создать одноименный метод обернутый декоратором

По умолчанию `@property` создаёт get свойство, атрибут можно получить, но не менять. Чтобы была возможность устанавливать значения
в атрибут, то нужно еще дополнительно создать аналогичный по названию метод, но с декоратором `@attr.setter`, где `attr` - название метода.

`setter` нельзя создать без `getter`, в обратную сторону это работает

```python
class Rectangle:
    def __init__(self, width: float, height: float):
        self._width = width
        self._height = height
    
        
    def get_width(self) -> float:
        """Так было раньше"""
        return self._width    
        
    @property
    def width(self) -> float:
        """Свойство для получения ширины"""
        return self._width
    
    def set_width(self, value: float):
        """Так было раньше"""
        if value <= 0:
            raise ValueError("Ширина должна быть положительным числом")
        self._width = value
    
    @width.setter
    def width(self, value: float):
        """Свойство для установки ширины с проверкой"""
        if value <= 0:
            raise ValueError("Ширина должна быть положительным числом")
        self._width = value
```


### Зачем нужны свойства?

* `Инкапсуляция`: Свойства позволяют скрыть внутренние детали реализации и предоставить более безопасный и удобный интерфейс. Например, если вам нужно изменить логику работы с атрибутом, но вы не хотите менять способ доступа к нему в коде, вы можете использовать свойства.

* `Контроль доступа`: Вы можете добавить логику проверки, обработки или модификации данных при попытке установить новое значение атрибута. Это позволяет предотвратить ошибки и обеспечивать целостность данных.

* `Вычисляемые атрибуты`: Иногда значения атрибутов могут зависеть от других данных. Свойства позволяют вычислять такие значения динамически при каждом обращении.


Так выглядит полный код изменений (заметьте, что `area` тоже стал свойством (это как раз вычисляемый атрибут)):

```python
class RectangleProperty:
    def __init__(self, width: float, height: float):
        self._width = width
        self._height = height

    @property
    def width(self) -> float:
        """Свойство для получения ширины"""
        return self._width

    @width.setter
    def width(self, value: float):
        """Свойство для установки ширины с проверкой"""
        if value <= 0:
            raise ValueError("Ширина должна быть положительным числом")
        self._width = value

    @property
    def height(self) -> float:
        """Свойство для получения высоты"""
        return self._height

    @height.setter
    def height(self, value: float):
        """Свойство для установки высоты с проверкой"""
        if value <= 0:
            raise ValueError("Высота должна быть положительным числом")
        self._height = value

    @property
    def area(self) -> float:
        """Вычисляемое свойство для площади прямоугольника"""
        return self._width * self._height

if __name__ == "__main__":
    
    # Пример со свойствами
    rect = RectangleProperty(5, 10)
    
    print(rect.width)  # 5
    rect.width = 7
    print(rect.area)  # 70
    
    try:
        rect.width = -3  # Ошибка: ValueError: Ширина должна быть положительным числом
    except ValueError as err:
        print(repr(err))
```

### Преимущества свойств

1. `Инкапсуляция без изменения интерфейса`: Вы можете начать с обычных публичных атрибутов, а затем, при необходимости, заменить их свойствами, не изменяя интерфейс класса.

2. `Удобство использования`: Для пользователя класса работа со свойствами ничем не отличается от работы с обычными атрибутами, но при этом вы сохраняете возможность добавления логики.

3. `Читаемость и поддерживаемость`: Код с использованием свойств проще читать и поддерживать, поскольку логика доступа к данным сосредоточена в одном месте.
