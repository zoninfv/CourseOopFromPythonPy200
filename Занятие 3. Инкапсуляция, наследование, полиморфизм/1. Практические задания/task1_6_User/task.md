
# Программа 'Управление доступом к данным':

Допишите класс `User`, который хранит конфиденциальные данные, такие как пароль и адрес. 

Обеспечьте доступ к этим данным только через методы с проверкой прав.

### Что нужно сделать?

Атрибуты `password` и `address` сделайте приватными, вспомните что нужно поставить `_` или `__` перед названием атрибута

Статический метод `check_permission` проверяет, что `role` равна `'admin'` и возвращает `True` если это так

Метод `get_password` проводит проверку доступа по роли, если прошла, то возвращает пароль, если не прошел проверку, то вызвать исключение `PermissionError` с текстом `'Доступ запрещен'`

Метод `get_address` проводит проверку доступа по роли, если прошла, то возвращает адрес, если не прошел проверку, то вызвать исключение `PermissionError` с текстом `'Доступ запрещен'`

___

Просто ознакомиться с текстом ниже, ничего переделывать не нужно. Рассмотренные ниже улучшения произведены в блоке `'3. Дополнительные задания'` в задаче `task1_User_update` 

### Какие могут быть сложности при дальнейшей расширении задачи и развитии кода?

Разработанный код в этой задаче является примером простого решения, однако такой подход имеет несколько потенциальных проблем, 
которые могут усложнить его поддержку и развитие в будущем. 

Рассмотрим основные недостатки и возможные сложности:

1. *Класс делает слишком много вещей*
* **Проблема**: В вашем классе `User` хранится информация о пользователе (логин, пароль, адрес), и этот же класс отвечает за то, кто может видеть эти данные. То есть он и хранит данные, и решает, кто имеет доступ к ним.
* **Почему это плохо**: Если вам нужно изменить, как управляются пароли, или добавить новые правила доступа, вам придется изменять код внутри класса `User`. Это может привести к тому, что класс станет слишком сложным и трудным для понимания.

2. *Невозможность легко добавлять новые роли*
* **Проблема**: У вас есть проверка на роль `"admin"`, которая жестко закодирована в методе `check_permission`. Это означает, что если нужно будет добавить новую роль (например, "менеджер"), вам придется менять код.
* **Почему это плохо**: Каждый раз, когда нужно добавить новую роль или изменить существующую, вам придется идти в код и редактировать его, что может привести к ошибкам и трудностям в поддержке.

3. *Логика разбросана по разным местам*
* **Проблема**: Логика проверки доступа находится в разных методах (`get_password` и `get_address`). То есть, если вы захотите изменить, кто имеет доступ к данным, вам придется изменить несколько мест в коде.
* **Почему это плохо**: Это делает код сложнее для понимания и изменения. Например, если вы забыли изменить логику в одном из методов, код может начать работать неправильно.

4. *Трудности с добавлением новых данных*
* **Проблема**: Если вы захотите добавить новый тип данных (например, номер телефона), вам придется добавить новый метод и снова написать всю логику доступа заново.
* **Почему это плохо**: Это делает код громоздким и увеличивает вероятность ошибок, так как вы повторяете одну и ту же логику снова и снова.

5. *Проблемы с безопасностью*
* **Проблема**: Данные, такие как пароль и адрес, все равно могут быть получены, если кто-то узнает, какую роль использовать для доступа.
* **Почему это плохо**: Это означает, что система может стать уязвимой. Если кто-то узнает роль `"admin"`, он сможет получить доступ к конфиденциальной информации.


### Как можно улучшить код?

* **Разделите обязанности**: Сделайте так, чтобы один класс отвечал за хранение данных, а другой — за управление доступом к этим данным. Это сделает код проще и понятнее.

* **Сделайте роли более гибкими**: Внедрите систему, где можно легко добавлять новые роли без необходимости менять существующий код.

* **Централизуйте проверку доступа**: Соберите всю логику, связанную с проверкой доступа, в одном месте, чтобы её было легче изменять и поддерживать.

Такой подход поможет вам создать код, который будет легче понимать, изменять и расширять в будущем.