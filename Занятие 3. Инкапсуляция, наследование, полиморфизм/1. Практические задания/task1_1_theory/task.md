# Блок заданий по теме инкапсуляция.

# Теоретическое задание (прочитать, запустить, ознакомиться с кодом)

## Что такое инкапсуляция?

Инкапсуляция — это принцип объектно-ориентированного программирования (ООП), который заключается в сокрытии внутренней реализации объекта и 
предоставлении доступа к его данным и методам только через определённые интерфейсы. Основная идея инкапсуляции заключается в том, 
чтобы защитить данные объекта от внешнего вмешательства и манипуляций, которые могут привести к непредсказуемому поведению системы.

Другими словами можно сказать, что инкапсуляция - это "заключение в капсулу" - ограничение доступа к содержимому "капсулы" 
из вне и отсутствие такого ограничения внутри "капсулы".

## Основные аспекты инкапсуляции:

1. Сокрытие данных (Encapsulation of Data):

> Данные объекта (атрибуты) обычно скрыты от внешнего доступа (используя модификаторы доступа, такие как `private` или `protected` 
в других языках или соглашения об именовании в Python, например, добавление символа _ перед именем атрибута).

2. Ограничение доступа (Access Restriction):

> Доступ к данным осуществляется через публичные методы (геттеры и сеттеры), которые обеспечивают контроль над тем, 
как данные читаются или изменяются.

3. Четкие интерфейсы (Clear Interfaces):

> Пользователям объектов предоставляется ограниченный набор методов (интерфейсов) для работы с ними. 
Внутренняя реализация объекта скрыта, что позволяет изменить её без влияния на код, который использует объект.



## Зачем нужен принцип инкапсуляции?

1. Защита данных:

> Инкапсуляция защищает внутренние данные объекта от прямого изменения извне, что помогает избежать ошибок и непредсказуемого поведения системы. Например, если у вас есть объект BankAccount, инкапсуляция может гарантировать, что баланс счета не может быть изменён напрямую, минуя проверку.

2. Снижение сложности:

> Инкапсуляция скрывает сложность реализации объекта и позволяет разработчикам сосредоточиться на использовании объекта, не беспокоясь о его внутренней структуре.

3. Поддержка и масштабируемость:

> Благодаря инкапсуляции, изменения во внутренней реализации объекта можно вносить без необходимости менять код, который использует этот объект. Это облегчает поддержку и обновление системы.

4. Улучшение модульности:

> Инкапсуляция способствует созданию модульных систем, где каждый модуль (объект) имеет чётко определённые функции и взаимодействует с другими модулями через хорошо определённые интерфейсы.

## Примеры инкапсуляции

### Плохая инкапсуляция

В этом примере атрибуты класса `BadBankAccount` открыты и могут быть изменены напрямую. Это может привести к неожиданным или неправильным изменениям данных.

```python
class BadBankAccount:
    def __init__(self, account_number: str, balance: float):
        self.account_number = account_number
        self.balance = balance

    def deposit(self, amount: float):
        self.balance += amount

    def withdraw(self, amount: float):
        if amount <= self.balance:
            self.balance -= amount
        else:
            print("Недостаточно средств")

if __name__ == "__main__":
    # -------- Пример плохой инкапсуляции --------------
    
    # Создаем объект банковского счета
    account = BadBankAccount("123456", 1000.0)

    # Плохая практика: Прямое изменение баланса извне
    account.balance = 5000.0  # Баланс можно изменить без проверок

    print(account.balance)  # 5000.0, что может быть ошибкой
```

#### Проблемы:
* `Отсутствие контроля`: Атрибут balance можно изменить напрямую, что нарушает логику работы методов deposit и withdraw.
* `Возможность ошибок`: Прямое изменение данных без проверок может привести к некорректным значениям, например, отрицательному балансу.
* `Уязвимость`: Баланс может быть случайно или намеренно изменён в обход правил бизнеса.

### Хорошая инкапсуляция

В этом примере атрибут `balance` скрыт (префикс _ указывает, что это частный атрибут), и к нему можно получить доступ только через методы, 
которые контролируют логику работы с балансом.

```python
class GoodBankAccount:
    def __init__(self, account_number: str, initial_balance: float):
        self.account_number = account_number
        self._balance = initial_balance  # Инкапсулированный атрибут

    def deposit(self, amount: float):
        if amount > 0:
            self._balance += amount
        else:
            print("Сумма депозита должна быть положительной")

    def withdraw(self, amount: float):
        if 0 < amount <= self._balance:
            self._balance -= amount
        else:
            print("Недостаточно средств или некорректная сумма")

    def get_balance(self) -> float:
        return self._balance

if __name__ == "__main__":
    # -------- Пример хорошей инкапсуляции --------------
    
    # Создаем объект банковского счета
    account = GoodBankAccount("123456", 1000.0)
    
    # Попытка изменить баланс напрямую не работает
    # account._balance = 5000.0  # Это плохая практика, так делать нельзя
    
    # Правильный способ изменения баланса через метод депозита
    account.deposit(500.0)
    print(account.get_balance())  # 1500.0
    
    # Правильный способ снятия денег
    account.withdraw(200.0)
    print(account.get_balance())  # 1300.0
    
    # Попытка снять больше средств, чем доступно
    account.withdraw(2000.0)  # "Недостаточно средств или некорректная сумма"
```