# Блок заданий по теме наследование.

# Теоретическое задание (прочитать, запустить, ознакомиться с кодом)

## Что такое наследование?

Наследование — это один из ключевых принципов объектно-ориентированного программирования (ООП). 
Этот принцип позволяет создавать новый класс на основе существующего класса. 
Новый класс (называемый потомком или производным классом) наследует свойства и методы родительского класса, 
что позволяет использовать и расширять уже существующий код.


## Зачем нужен этот принцип?

Наследование помогает решать несколько задач в программировании:

* `Повторное использование кода`: В наследуемом классе можно использовать уже существующие методы и свойства родительского класса, не переписывая их заново. Это значительно уменьшает количество повторяющегося кода и облегчает его поддержку.

* `Расширение функциональности`: Наследуя класс, можно добавлять новые методы и свойства, специфичные для нового класса, или переопределять методы родительского класса, если нужно изменить их поведение.

* `Создание иерархий классов`: Наследование позволяет организовать классы в иерархии, где более общие классы находятся на вершине, а более специфичные — внизу. Это помогает лучше структурировать код и управлять сложными системами.


## Где полезно наследование?

Наследование полезно во многих ситуациях, например:

* `Построение иерархий типов`: Например, если вы создаете систему для управления сотрудниками, у вас может быть общий класс `Employee`, от которого будут наследоваться классы `Manager`, `Engineer`, `Intern` и т.д. Все они будут иметь общие атрибуты и методы, но также смогут иметь и свои уникальные.

* `Создание библиотек и фреймворков`: Наследование широко используется при разработке библиотек и фреймворков. Например, в библиотеке для работы с графическим интерфейсом может быть базовый класс `Widget`, от которого наследуются более конкретные классы, такие как `Button`, `TextBox`, `Label` и т.д.

* `Расширение существующего кода`: Если вам нужно добавить новую функциональность к существующему классу, но вы не хотите изменять его исходный код, вы можете создать подкласс и добавить или изменить необходимую функциональность в нем.

## Пример

Наследование это своего рода `полное внутреннее копирование класса`, со всеми его `атрибутами и методами`. 

Чтобы провести наследование от класса, то необходимо указать этот класс в скобках.

```python
class A:
    class_attr = 10  # классовый атрибут

    def __init__(self, param):
        self.param = param  # экземплярный атрибут

    def get_param(self):  # экземплярный метод
        return self.param


class B(A):  # Так происходит наследование, теперь в классе B есть все тоже самое, что и в классе A
    ...


if __name__ == "__main__":
    obj_a = A(20)
    obj_b = B(40)  # хотя мы и не писали __init__(self, param) в классе B, но оно полностью скопировалось из класса A

    print(obj_a.get_param())  # 20
    print(obj_b.get_param())  # 40  Скопировали все методы

    print(obj_a.class_attr)  # 10
    print(obj_b.class_attr)  # 10 Атрибуты тоже скопировались

    obj_a.change_class_attr(20)  # Изменили классовый атрибут класса А
    obj_b.change_class_attr(30)  # Изменили классовый атрибут класса B

    print(obj_a.class_attr)  # 20
    print(obj_b.class_attr)  # 30  Копирование есть копирование, даже классовых атрибутов, они теперь независимые

```

## А что делать если в новом классе хочу добавить атрибут или метод?

Всё просто хотим что-то добавить, просто это делаем. Единственное что нужно помнить, что если атрибут или метод 
в новом классе называется также как и в прошлом, то они перезапишутся (методы и атрибуты в старом классе никак не затронутся,
помните что читали ранее, при наследованиии ВСЁ ПОЛНОСТЬЮ КОПИРУЕТСЯ в новый (дочерний) класс, поэтому любые изменения в новом классе 
НИКАК НЕ ЗАТРОНУТ старый (родительский) класс). 

```python
class A:
    class_attr = 10  # классовый атрибут

    def __init__(self, param):
        self.param = param  # экземплярный атрибут

    @classmethod
    def change_class_attr(cls, value):
        cls.class_attr = value

    def get_param(self):  # экземплярный метод
        return self.param


class B(A):  # В классе мы прописываем, то что хотим добавить относительно родительского класса A
    new_attr = 'Это классовый атрибут класса B'

    @staticmethod
    def hello():  # Добавили метод которого не было в классе A
        print("Привет из класса B")


if __name__ == "__main__":
    obj_a = A(20)
    obj_b = B(40)

    print(obj_b.class_attr)  # 10 Есть атрибут скопированный из класса А
    print(obj_b.new_attr)  # 'Это классовый атрибут класса B' и новый атрибут которого нет в классе A

    print(obj_b.get_param())  # 40 Есть метод скопированный из класса А
    obj_b.hello()  # "Привет из класса B" и новый метод которого нет в классе A
```

Как мы видим это и есть наследование, когда мы всё берем от родителя и если это необходимо (а в большинстве случаев необходимо), 
то добавляем новый функционал. И как видите код из родительского класса мы сами не копируем за нас это делает Python, поэтому кода
не так много.


## А что делать если хочется провести наследование от нескольких классов? 

Python поддерживает механизм множественного наследования, для этого при наследовании просто перечислите какие классы необходимо скопировать

```python
class A:
    attr_A = 10

    def __init__(self, param_a):
        self.param_a = param_a

    def method_a(self):
        return 'A'


class B:
    attr_B = 20

    def __init__(self, param_b):
        self.param_b = param_b

    def method_b(self):
        return 'B'


class C(A, B):  # Множественное наследование
    attr_С = 30

    def method_c(self):
        return 'C'


if __name__ == "__main__":
    obj_c = C(30)  # def __init__ тоже скопировался, но с какого класса?

    print(obj_c.param_a)  # 30 Скопировался только __init__ с класса A, так как при одинаковых названиях оставляется
    # тот чей класс левее при наследовании
    try:
        print(obj_c.param_b)
    except AttributeError as err:
        print(err)  # 'C' object has no attribute 'param_b'

    # Остальные методы и атрибуты скопировались полностью, так как их названия не повторяются
    print(obj_c.method_a(), obj_c.method_b(), obj_c.method_c())  # A B C
    print(obj_c.attr_A, obj_c.attr_B, obj_c.attr_С)  # 10 20 30
```
